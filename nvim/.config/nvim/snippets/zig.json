{"if":{"body":"if ($1) {$0}","prefix":"if"},"union tagged":{"body":"const $1 = union(${2:enum}) {$0};","prefix":"union-tagged-top"},"struct-1":{"body":"struct {$0};","prefix":"struct"},"catch switch":{"body":"catch |${1:err}| switch (${1:err}) {$0};","prefix":"catch switch"},"expectEqual":{"body":"try std.testing.expectEqual(${1:expected}, ${2:result});","prefix":"expectEqual"},"format":{"body":["pub fn format(","    ${1:self}: ${2:@This()},","    comptime fmt: []const u8,","    options: std.fmt.FormatOptions,","    writer: anytype,",") !void {$0}"],"prefix":"format"},"if else":{"body":"if ($1) {$2} else {$0}","prefix":"if else"},"log err":{"body":"std.log.err(\"$1\\n\", .{$0});","prefix":"log err"},"fn":{"body":"fn ${1:name}($2) ${3:!void} {$0}","prefix":"fn"},"while":{"body":"while ($1) {$0}","prefix":"while"},"gpa":{"body":["var gpa = std.heap.GeneralPurposeAllocator(.{}){};","const allocator = gpa.allocator();","defer {","    const deinit = gpa.deinit();","    if (deinit == .leak) @panic(\"LEAK DETECTED\");","}"],"prefix":"gpa"},"union":{"body":"const $1 = union {$0};","prefix":"union-top"},"pub fn":{"body":"pub fn ${1:name}($2) ${3:!void} {$0}","prefix":"pub fn"},"main":{"body":"pub fn main() !void {$0}","prefix":"main"},"std":{"body":"const std = @import(\"std\");","prefix":"std"},"expect":{"body":"try std.testing.expect(${1:bool});","prefix":"expect"},"enum-1":{"body":"enum {$0}","prefix":"enum"},"switch":{"prefix":"switch","body":"switch ($1) {$0}"},"test":{"body":["test \"$TM_FILENAME_BASE $1\" {","  $0","}"],"prefix":"test"},"std_options":{"body":"pub const std_options: std.Options = .{$0};","prefix":"std_options"},"asmv":{"body":"asm volatile (${1:input}, ${0:input})","prefix":"asmv"},"aoc":{"body":["const lib = @import(\"lib\");","const std = @import(\"std\");","","const input = @embedFile(\"data/day${1:00}/data.txt\");","const example = @embedFile(\"data/day$1/example.txt\");","","$0pub fn part1(_: std.mem.Allocator) anyerror!usize {","    var linesIter = std.mem.tokenizeScalar(u8, example, '\\n');","","    while (linesIter.next()) |line| {","        std.debug.print(\"{s}\\n\", .{line});","    }","","    return 42;","}","","pub fn part2(_: std.mem.Allocator) anyerror!usize {","    var linesIter = std.mem.tokenizeScalar(u8, example, '\\n');","","    while (linesIter.next()) |line| {","        std.debug.print(\"{s}\\n\", .{line});","    }","","    return 42;","}","","const t = std.testing;","","test \"day$1 part1\" {","    _ = try lib.validate(part1, 42, lib.Day.$2, lib.Part.one, t.allocator);","}","","test \"day$1 part2\" {","    _ = try lib.validate(part2, 42, lib.Day.$2, lib.Part.two, t.allocator);","}"],"prefix":"aoc"},"enum":{"body":"const $1 = enum {$0};","prefix":"enum-top"},"struct":{"body":"const $1 = struct {$0};","prefix":"struct-top"},"import":{"body":"const $1 = @import(\"$2\");","prefix":"import"},"error set":{"body":"const ${1:Error} = error {$0};","prefix":"error-top"},"panic":{"body":["pub fn panic(","    msg: []const u8,","    trace: ?*std.builtin.StackTrace,","    ret_addr: ?usize,",") noreturn {$0}"],"prefix":"panic"},"callconv":{"body":"callconv($0)","prefix":"callconv"},"expectEqualStrings":{"body":"try std.testing.expectEqualStrings(${1:expected}, ${2:actual});","prefix":"expectEqualStrings"},"print":{"body":"std.debug.print(\"${1:content}\\n\", .{$0});","prefix":"print"},"log debug":{"body":"std.log.debug(\"$1\\n\", .{$0});","prefix":"log debug"},"else":{"body":"else {$0}","prefix":"else"},"log warn":{"body":"std.log.warn(\"$1\\n\", .{$0});","prefix":"log warn"},"log info":{"body":"std.log.info(\"$1\\n\", .{$0});","prefix":"log info"},"eql":{"body":"std.mem.eql(${1:comptime T: type}, ${2:a: []const T}, ${3:b: []const T})","prefix":"eql"},"for":{"body":"for ($1) |${2:value}| {$0}","prefix":"for"},"root":{"body":"const root = @import(\"root\");","prefix":"root"},"fori":{"body":"for ($1, 0..) |${2:value}, ${3:i}| {$0}","prefix":"fori"}}